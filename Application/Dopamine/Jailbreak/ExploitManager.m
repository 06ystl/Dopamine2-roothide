//
//  ExploitManager.m
//  Dopamine
//
//  Created by Lars Fr√∂der on 09.01.24.
//

#import "ExploitManager.h"
#import "Exploit.h"

#import <libgrabkernel/libgrabkernel.h>

@implementation ExploitManager

+ (instancetype)sharedManager
{
    static ExploitManager *shared;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        shared = [[ExploitManager alloc] init];
    });
    return shared;
}

- (instancetype)init
{
    self = [super init];
    if (self) {
        [self _loadAvailableExploits];
    }
    return self;
}

- (void)_loadAvailableExploits
{
    NSMutableSet *exploitSet = [NSMutableSet new];
    NSString *exploitPath = [[NSBundle mainBundle].bundlePath stringByAppendingPathComponent:@"Frameworks/Exploits"];
    NSArray *contents = [[NSFileManager defaultManager] contentsOfDirectoryAtPath:exploitPath error:nil];
    if (contents) {
        for (NSString *exploitFrameworkName in contents) {
            NSString *exploitFrameworkPath = [exploitPath stringByAppendingPathComponent:exploitFrameworkName];
            NSDictionary *exploitInfo = [NSDictionary dictionaryWithContentsOfFile:[exploitFrameworkPath stringByAppendingPathComponent:@"Info.plist"]];
            if (exploitInfo) {
                NSDictionary *flavors = exploitInfo[@"DPExploitFlavors"];
                [flavors enumerateKeysAndObjectsUsingBlock:^(NSString *flavorName, NSDictionary *flavorDict, BOOL *stop) {
                    [exploitSet addObject:[[Exploit alloc] initWithPath:exploitFrameworkPath flavorName:flavorName flavorDictionary:flavorDict]];
                }];
            }
        }
    }
    _allExploits = [exploitSet copy];
    NSLog(@"Loaded exploits: %@", _allExploits);
}

- (NSSet<Exploit *> *)_availableExploitsForType:(ExploitType)type
{
    NSMutableSet *subset = [NSMutableSet new];
    for (Exploit *exploit in _allExploits) {
        if (exploit.type == type) {
            [subset addObject:exploit];
        }
    }
    return subset;
}

- (Exploit *)_preferredExploitForType:(ExploitType)type
{
    Exploit *preferredExploit = nil;
    for (Exploit *exploit in [self _availableExploitsForType:type]) {
        if (!preferredExploit || exploit.priority > preferredExploit.priority) {
            preferredExploit = exploit;
        }
    }
    return preferredExploit;
}

// TODO: Make overwritable from preferences

- (Exploit *)preferredKernelExploit
{
    return [self _preferredExploitForType:EXPLOIT_TYPE_KERNEL];
}

- (Exploit *)preferredPACBypass
{
    return [self _preferredExploitForType:EXPLOIT_TYPE_PAC];
}

- (Exploit *)preferredPPLBypass
{
    return [self _preferredExploitForType:EXPLOIT_TYPE_PPL];
}

- (int)cleanUpExploits
{
    for (Exploit *exploit in [_activeExploits reverseObjectEnumerator]) {
        int r = [exploit cleanup];
        if (r != 0) return r;
    }
    return 0;
}

@end
